Module 1: Introduction to Software Engineering
    Software engineering is the process of designing, developing, testing, and maintaining software. It applies engineering principles to software development to make sure programs work efficiently and meet user needs.
    Importance of Software Engineering
    Software engineering is essential because it helps create reliable, efficient, and secure software. It ensures that software is developed in a structured way, reducing errors and making maintenance easier. Without 
    proper software engineering, programs may fail, be difficult to update, or contain security risks.
    Software Development Life Cycle (SDLC)
SDLC is a step-by-step process used in software development. It includes:
    1.	Planning – Understanding what the software should do.
    2.	Design – Creating a blueprint for the software.
    3.	Implementation/Development – Writing the code.
    4.	Testing – Checking for errors and fixing them.
    5.	Deployment – Releasing the software for use.
    6.	Maintenance – Updating and improving the software over time.
Software Engineering Models
 Different models are used to develop software, including:
    •	Waterfall Model – A step-by-step approach where each phase is completed before moving to the next.
    •	Agile Model – A flexible method that allows changes and improvements during development.
    •	Spiral Model – A mix of planning and testing to reduce risks.
Key Principles of Software Engineering
    1.	Modularity – Breaking software into smaller parts for easier management.
    2.	Scalability – Ensuring software can handle more users and data over time.
    3.	Security – Protecting data and software from threats.
    4.	Efficiency – Writing code that runs quickly and uses resources wisely.
    5.	Maintainability – Making sure the software can be updated easily.
    
Module 2: Basics of Programming
This module focuses on programming fundamentals, including programming languages and constructs. You will explore the differences between various programming languages and gain an understanding of basic programming concepts such as variables, control structures, and data types.
1.	Different Types of Programming Languages
    a.	High-Level Languages: 
        •	Definition: Languages that are closer to human languages and abstract away most of the hardware details.
        •	Examples: Python, Java, C#, Ruby.
        •	Advantages: Easier to read and write, faster development, and better for complex applications.
    b.	Low-Level Languages: 
    •	Definition: Languages that provide little abstraction from a computer's instruction set architecture.
    •	Examples: Assembly language, C.
    •	Advantages: Greater control over hardware, better performance for system-level programming.
    c.	Compiled Languages: 
    •	Definition: Languages that are transformed into machine code by a compiler before execution.
    •	Examples: C, C++, Rust.
    •	Advantages: Typically, faster execution due to direct machine code execution.
    d.	Interpreted Languages: 
    •	Definition: Languages that are executed line-by-line by an interpreter at runtime.
    •	Examples: Python, JavaScript, Ruby.
    •	Advantages: Easier to test and debug, platform-independent code.
    e.	Scripting Languages: 
    •	Definition: Often interpreted languages used for automating tasks and manipulating data.
    •	Examples: Bash, PowerShell, Python.
    •	Advantages: Quick development cycles for small tasks, often easier for beginners.
2.	Basic Programming Constructs
    a.	Variables: 
     •	Definition: Containers for storing data values.
    b.	Control Structures: 
    i.	Conditionals: 
     •	Definition: Statements that execute different code based on whether a condition is true or false.
    ii.	Loops: 
     •	Definition: Constructs that repeat a block of code multiple times.
   Types: 
        •	For Loop: Iterates a specific number of times. 
        •	While Loop: Continues if a condition is true. 
        •	Do-While Loop: Executes at least once before checking the condition. 
    c.	Functions: 
     •	Definition: Reusable blocks of code that perform a specific task.
3.	How Websites and Cloud Applications Work
    •	Websites: Composed of front-end (client-side) and back-end (server-side) components that interact to deliver content to users.
    •	Cloud Applications: Hosted on cloud servers, providing accessibility and scalability, allowing users to interact with applications over the internet.
4.	The Technologies You Can Use to Create Reactive and Responsive Websites
    a.	Front-End Technologies: 
        •	HTML: Markup language for structuring web content.
        •	CSS: Stylesheet language for presentation and layout.
        •	JavaScript: Programming language for interactivity and dynamic content.
        •	Frameworks: React, Angular, Vue.js for building reactive user interfaces.
5.	The Back-End Technologies You Can Use to Create Functionality in Your Websites
    •	Server-Side Languages: Python, Java, Ruby, PHP, and Node.js for server logic.
    •	Databases: MySQL, PostgreSQL, MongoDB for data storage and retrieval.
    •	Frameworks: Express.js, Django, Spring for building server applications.
6.	How Teams and Squads Work in a Software Engineering Context
    •	Team Structures: Agile teams organized into cross-functional squads that include developers, designers, and testers.
    •	Collaboration: Emphasis on communication, collaboration, and shared responsibility to enhance productivity.
7.	The Benefits of Different Pair Programming Styles
    •	Driver/Navigator: One person writes the code (driver) while the other reviews and guides the process (navigator).
    •	Ping-Pong: Team members switch roles frequently, promoting collaboration and knowledge sharing.
    •	Mob Programming: The entire team collaborates on the same code at the same time, fostering a collective approach.
    •	Strong style – A junior developer is a navigator while the senior is a driver. 
8.	Common Web Technologies into Front-End and Back-End Technologies
    •	Front-End: HTML, CSS, JavaScript, frameworks like React and Angular.
    •	Back-End: Server-side languages (Python, Java), databases (MySQL, MongoDB), and server frameworks (Express.js, Django).
9.	Commonly Used Types of Development Tools
    •	Version Control Software: Git, SVN for tracking changes in code.
    •	Libraries and Frameworks: Pre-written code to streamline development.
    •	Build Tools: Webpack, Gulp for automating tasks.
10.	 Key Developer Tools
    •	CI/CD Tools: Jenkins, Travis CI for automating testing and deployment processes.
    •	Build Tools: Tools that compile and package applications for deployment.
    •	Package Managers: npm, Yarn for managing project dependencies.
11.	Describe Software Stacks and Identify the Advantages of Three Popular Stacks
    •	MEAN Stack: MongoDB, Express.js, Angular, Node.js. 
      o	Advantages: Full JavaScript development, real-time applications.
    •	LAMP Stack: Linux, Apache, MySQL, PHP. 
      o	Advantages: Stability, cost-effectiveness, and wide community support.
    •	MERN Stack: MongoDB, Express.js, React, Node.js. 
      o	Advantages: React's component-based architecture, seamless data flow.
   	
Module 3: Basics of Programming
    This module basically introduces you as a beginner to the basics of programming. In the first lesson, you get learn about the different categories of programming languages and the scenarios to which each is suited. 
    You’ll also learn how to plan and organize your code effectively. In Lesson 2, you will explore basic programming logic and investigate programming concepts such as identifiers, functions, and objects. Finally, in 
    the hands-on lab, you’ll learn how to write simple Python code.
1.	Interpreted Programming Languages and Compiled Programming Languages
    a.	Interpreted Languages: 
        •	Definition: Languages that are executed line-by-line by an interpreter at runtime.
        •	Examples: Python, JavaScript, Ruby.
    b.	Compiled Languages: 
        •	Definition: Languages that are transformed into machine code by a compiler before execution.
        •	Examples: C, C++, Rust.
2.	Interpreted and Compiled Programming Languages
    a.	Execution Speed: Compiled languages generally run faster as they are converted to machine code, while interpreted languages may have slower runtime performance due to interpretation.
    b.	Error Detection: Compiled languages catch errors at compile time, while interpreted languages may only reveal errors at runtime.
    c.	Portability: Interpreted languages are often more portable across platforms because they rely on an interpreter, while compiled languages may require recompilation for different environments.
3.	Query Languages and Assembly Language
    a.	Query Languages: 
        •	Definition: Specialized languages designed for managing and manipulating databases.
        •	Examples: SQL (Structured Query Language) is used for querying relational databases.
    b.	Assembly Languages: 
        •	Definition: Low-level languages that provide a symbolic representation of machine code, closely related to the architecture of the hardware.
        •	Purpose: Used for system-level programming and where high performance is required.
4.	Two Main Methods of Organizing and Planning Code and the Advantages of Each
    a.	Top-Down Design: 
        •	Definition: Breaking down a system into smaller components or modules, starting from the highest level of abstraction.
        •	Advantages: Facilitates understanding of the overall system and allows for incremental development.
    b.	Bottom-Up Design: 
        •	Definition: Starting with detailed components and building up to a complete system.
        •	Advantages: Encourages reusability of components and can lead to more efficient small modules.
5.	Design Simple Flowcharts
    a.	Definition: Flowcharts are visual representations of a process or algorithm.
    b.	Purpose: To illustrate the flow of control in a program, making it easier to understand the logic and structure.
6.	List the Differences Between Branching and Looping
    a.	Branching: 
        Definition: A control structure that allows the program to take different paths based on conditions (e.g., if, else statements).
    b.	Looping: 
        Definition: A control structure that repeats a block of code multiple times based on a condition (e.g., for loops, while loops).
7.	Describe the Purpose and Use of Identifiers and Containers
    a.	Identifiers: 
        •	Definition: Names given to variables, functions, and other entities to identify them in code.
        •	Purpose: To provide meaningful context and improve code readability.
    b.	Containers: 
        •	Definition: Data structures that hold multiple values, such as arrays, lists, and dictionaries.
        •	Purpose: To organize and manage collections of data efficiently.
8.	Describe the Purpose and Use of Functions and Objects
    a.	Functions: 
        •	Definition: Reusable blocks of code that perform a specific task.
        •	Purpose: To promote code reusability and modularity.
    b.	Objects: 
        •	Definition: Instances of classes that encapsulate data and behaviour.
        •	Purpose: To model real-world entities and facilitate object-oriented programming.
9.	Write and Run Simple Python Code That Uses Variables, Constants, Arrays, Loops, and Conditional Logic
    a.	Hands-On Lab: You will learn to write Python code that demonstrates the use of: 
        •	Variables: Storing data values.
        •	Constants: Fixed values that do not change.
        •	Arrays (Lists in Python): Storing multiple values.
        •	Loops: Iterating over data.
        •	Conditional Logic: Making decisions based on conditions.
  	
Module 4: Software Architecture, Design, and Patterns
    This module covered the foundations of enterprise software development. Lesson 1 introduced you to software architecture and explains the importance of well-designed architecture. also learnt about the design 
    process, including structural design, behavioural models, and how to create Unified Modelling Language (UML) diagrams to communicate a software’s structure and behaviour to all team members. Additionally, I 
    considered object-oriented analysis and design (OOAD). In Lesson 2, I explored a variety of architectural patterns that support the architectural design process through hands-on activities. Lastly, I learnt about the 
    software production environment and components required for deployment.
1.	Describe What Software Architecture Is and Explain Its Importance
    a.	Software Architecture: The high-level structure of a software system, defining its components and their interactions.
    b.	Importance: A well-designed architecture ensures system scalability, maintainability, and performance while facilitating team collaboration and communication.
2.	Compare and Contrast Structural Design with Behavioural Models and Discuss the Usefulness of UML Diagrams
    a.	Structural Design: 
        •	Definition: Focuses on the organization and composition of the system’s components.
    b.	Behavioural Models: 
        •	Definition: Describe the dynamic behaviours of the system and how components interact over time.
    c.	UML Diagrams: 
        •	Usefulness: Provide a visual representation of both structural and behavioural aspects, improving communication among team members.
3.	Explain Object-Oriented Analysis and Design (OOAD)
    a.	Definition: A methodology that uses object-oriented concepts to analyse and design a software system.
    b.	Components: Focuses on modelling real-world entities as objects, encapsulating data and behaviour, and promoting reusability through inheritance and polymorphism.
4.	Describe Component-Based and Service-Oriented Architectures and the Characteristics of Distributed Systems
    a.	Component-Based Architecture: 
        •	Definition: A design approach that emphasizes the decomposition of software into reusable components.
    b.	Service-Oriented Architecture (SOA): 
        •	Definition: An architectural pattern where services are provided to other components via a network.
    c.	Distributed Systems: Systems that consist of multiple independent components located on different networked computers, which communicate and coordinate their actions.
5.	Differentiate Among 2-Tier, 3-Tier, Peer-to-Peer, Event-Driven, and Microservices Architectural Patterns
    a.	2-Tier Architecture: 
        •	Definition: A client-server architecture where the client directly communicates with the server.
        •	Example: Traditional desktop applications accessing a database directly.
    b.	3-Tier Architecture: 
        •	Definition: Separates the presentation, business logic, and data layers.
        •	Example: Web applications with separate web, application, and database servers.
    c.	Peer-to-Peer Architecture: 
        •	Definition: A decentralized network where each node can act as both a client and a server.
        •	Example: File-sharing applications like BitTorrent.
    d.	Event-Driven Architecture: 
        •	Definition: A design pattern where events trigger actions or responses within the system.
        •	Example: Real-time data processing systems that react to incoming data streams.
    e.	Microservices Architecture: 
        •	Definition: Composed of small, independent services that communicate over a network.
        •	Example: E-commerce platforms where each service handles different functionalities (e.g., payment processing, inventory management).
6.	Components Commonly Required in a Production Environment
    a.	Servers: Hardware or virtual machines running applications.
    b.	Databases: Systems for storing and managing data.
    c.	Load Balancers: Distribute incoming traffic across multiple servers.
    d.	Monitoring Tools: Track performance and availability of applications.
7.	Recognize Diagrams of Architectural Patterns Based on Their Descriptions
    a.	Diagrams: Understand how to interpret and create visual representations of various architectural patterns, facilitating better communication and design validation.

MODULE 5: Job Opportunities and Skillset in Software Engineering
    This module covered the tasks of a software engineer and what they do on a day-to-day basis. I also discover the hard and soft skills needed to become a successful software engineer. Additionally, I did a task that 
    required to do the job outlook for software engineers, understand different career paths, and learn about various software engineering job titles and their responsibilities. Finally, I explored the software 
    engineering code of ethics.
1.	Match Role Titles with Job Responsibilities
    •	Software Developer: Responsible for writing and testing code.
    •	Quality Assurance Engineer: Focuses on testing software for defects.
    •	DevOps Engineer: Manages deployment and infrastructure automation.
    •	Systems Analyst: Works on system requirements and design.
2.	Software Engineers and Describe the Key Skills Required for Those Roles
    a.	Front-End Developer: 
     i.	Skills: HTML, CSS, JavaScript, frameworks (React, Angular).
    b.	Back-End Developer: 
     i.	Skills: Server-side languages (Python, Java, Node.js), database management.
    c.	Full-Stack Developer: 
     i.	Skills: Proficiency in both front-end and back-end technologies.
3.	Hard and Soft Skills for Software Engineers and Examples
    a.	Hard Skills: 
        •	Definition: Technical skills required to perform specific tasks.
        •	Examples: Programming languages, database management, version control (Git).
    b.	Soft Skills: 
        •	Definition: Interpersonal skills that enhance collaboration and communication.
        •	Examples: Problem-solving, teamwork, time management, adaptability.
4.	What a Software Engineer Does and the Technologies That They Use
    a.	Role Overview: Software engineers design, develop, test, and maintain software applications.
    b.	Technologies Used: Programming languages, development frameworks, version control systems, integrated development environments (IDEs), and cloud services.
5.	Popular Career Paths for Software Engineers
    a.	Career Paths: 
        •	Technical Lead: Oversees technical aspects of projects.
        •	Engineering Manager: Manages engineering teams and projects.
        •	Site Reliability Engineer: Focuses on system reliability and uptime.
        •	Data Engineer: Works with data architecture and pipeline development.
6.	Explain Each of the Eight Principles in the Software Engineering Code of Ethics
    a.	Public: Act in the public interest and prioritize the safety, health, and welfare of the public.
    b.	Client and Employer: Act in the best interest of clients and employers while maintaining integrity.
    c.	Product: Ensure the products and services are of high quality and meet established standards.
    d.	Judgment: Maintain integrity and independence in professional judgment.
    e.	Management: Promote ethical management practices and support the development of software engineers.
    f.	Profession: Uphold the reputation and integrity of the profession through ethical conduct.
    g.	Colleagues: Treat colleagues with respect and promote a supportive work environment.
    h.	Self: Engage in lifelong learning and professional development to enhance skills.
